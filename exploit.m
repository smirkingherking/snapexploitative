%%  (.m) Octave/Matlab

function exploit()

%% -------------------
%%  Init GUI elements
%% -------------------

bg_color = [0.85 0.85 0.85];
main_fig = figure('color', bg_color, ...
                  'menubar', 'none', ...
                  'units', 'normalized', ...
                  'position', [0.25 0.25 0.5 0.5], ...
                  'name', 'Turn 6: Marvel Snap Exploitative Strategy', ...
                  'numbertitle', 'off', ...
                  'defaultuicontrolfontsize', 12, ...
                  'defaultuicontrolunits', 'normalized', ...
                  'defaultuicontrolhorizontalalignment', 'left', ...
                  'defaultuicontrolbackgroundcolor', bg_color, ...
                  'defaultuipanelbackgroundcolor', bg_color, ...
                  'defaultpatchcdatamapping', 'direct', ...
                  'defaultpatchedgecolor', [0.42 0.42 0.42]);

left_margin = 0.05;
panel_height = 0.37;
options_panel_x = 0.8;
num_options = 2;
option_y = (1:num_options).*((1-(num_options)*0.08)/(num_options+1))+(0:num_options-1)*0.08;

main_gui.options_panel = uipanel('title', 'Options', 'position', [options_panel_x 0 1-options_panel_x panel_height]);
main_gui.allow_zero = uicontrol('style', 'checkbox', 'parent', main_gui.options_panel, ...
  'position', [left_margin option_y(1) 1 0.08], 'string', 'Allow 0% Opp Strategies');
main_gui.show_ev = uicontrol('style', 'checkbox', 'parent', main_gui.options_panel, ...
  'position', [left_margin option_y(2) 1 0.08], 'string', 'Show EV Graphs', 'value', 1, 'callback', @update_sliders);

strat_panels_pos = [0 0 options_panel_x panel_height];
main_gui.initial_panel = uipanel('title', 'Opp Initial Action', ...
  'position', [strat_panels_pos(1) strat_panels_pos(2) strat_panels_pos(3)/2 strat_panels_pos(4)]);
main_gui.response_panel = uipanel('title', 'Opp Response To Snap', ...
  'position', [strat_panels_pos(3)/2 strat_panels_pos(2) strat_panels_pos(3)/2 strat_panels_pos(4)]);

axes_padding = 0.04;
axes_pos = [axes_padding, panel_height+2*axes_padding, 1-2*axes_padding, 0.95*(0.92-panel_height-4*axes_padding)];
main_gui.axes = axes('units', 'normalized', ...
                     'position', axes_pos, ...
                     'fontsize', 12, ...
                     'layer', 'top', ...
                     'xgrid', 'on', ...
                     'xminorgrid', 'on', ...
                     'ygrid', 'on', ...
                     'gridlinestyle', ':', ...
                     'gridalpha', 0.5, ...
                     'minorgridalpha', 0.5, ...
                     'xlimmode', 'manual', ...
                     'ylimmode', 'manual', ...
                     'xlim', [0 1], ...
                     'ylim', [-2 8], ...
                     'xtick', 0:0.125:1, ...
                     'ytick', -2:1:8, ...
                     'userdata', 'idle');

xlabel('Your % Chance to Win Once All Cards Are Revealed');
ylabel('Cube EV');


%%main_gui.gto_ev = arrayfun(@(w)((w>0.625) - (w<0.375) + (w>=0.375 & w<=0.625) .* (8*w-4)), 0:main_gui.w_tick:1);
main_gui.w_tick = 0.025;
colors = hsv(9);
main_gui.strat_colors = arrayfun(@(c)(1-(0.56*(1-c))), colors(1:7,:));
colormap(main_gui.strat_colors);

%%  Helper functions to encapsulate common property-value pairs
ui_slider = @(p, pos, val) uicontrol('style', 'slider', 'parent', p, 'position', pos, 'value', val, ...
                                      'busyaction', 'cancel', 'interruptible', false, 'callback', @update_sliders);

ui_text = @(p, pos, varargin) uicontrol('style', 'text', 'parent', p, 'position', pos, varargin{:});


%% ----------------------
%%  Strategy Legend Init
%% ----------------------
legend_width = 0.1; legend_height = 0.04;
legend_y_pos = 0.92; legend_x_pos = (1:7).*((1-7*legend_width)/8) + (0:6).*legend_width;
legend_split_x = mean([legend_x_pos(4) + legend_width, legend_x_pos(5)]);
main_gui.legend_panel_left = uipanel('position', [0 legend_y_pos-0.02 legend_split_x 1]);
main_gui.legend_panel_right = uipanel('position', [legend_split_x legend_y_pos-0.02 1 1]);

ui_legend = @(i, str) uicontrol('style', 'text', 'parent', main_fig, 'string', str, ...
                                'position', [legend_x_pos(i) legend_y_pos legend_width legend_height], ...
                                'backgroundcolor', main_gui.strat_colors(i,:), ...
                                'foregroundcolor', 'k', 'horizontalalignment', 'center');

main_gui.legend_desc_play = ui_text(main_fig, [legend_x_pos(1) legend_y_pos+legend_height 4*legend_width legend_height], ...
                                    'string', 'Your Strategy If Opp Plays Their Option:', 'horizontalalignment', 'center');
main_gui.legend_desc_snap = ui_text(main_fig, [legend_x_pos(5) legend_y_pos+legend_height 3*legend_width legend_height], ...
                                    'string', 'Your Strategy If Opp Snaps Immediately:', 'horizontalalignment', 'center');
main_gui.legend_r   = ui_legend(1, 'Retreat');
main_gui.legend_p   = ui_legend(2, 'Play');
main_gui.legend_s_r = ui_legend(3, 'Snap-Retreat');
main_gui.legend_s_p = ui_legend(4, 'Snap-Play');
main_gui.legend_r_s = ui_legend(5, 'Retreat');
main_gui.legend_p_s = ui_legend(6, 'Play');
main_gui.legend_s_s = ui_legend(7, 'Snap');


%% ------------------------
%%  Slider/Label Positions
%% ------------------------
slider_width = 0.8; slider_height = 0.07;
Vp_y = 0.65; Vs_y = 0.15; Vp_s_y = Vp_y + 0.11; Vs_s_y = Vp_y - 0.11;
label_offset = 0.1; label_height = 0.08; label_width = 1;

Vp_pos = [left_margin Vp_y slider_width slider_height];
Vp_label_pos = [left_margin Vp_pos(2)+label_offset label_width label_height];

Vs_pos = [left_margin Vs_y slider_width slider_height];
Vs_label_pos = [left_margin Vs_pos(2)+label_offset label_width label_height];

Vr_label_pos = [left_margin mean([Vp_pos(2) Vs_pos(2)]) label_width label_height];

Vp_s_pos = [left_margin Vp_s_y slider_width slider_height];
Vp_s_label_pos = [left_margin Vp_s_pos(2)+label_offset label_width label_height];

Vs_s_pos = [left_margin Vs_s_y slider_width slider_height];
Vs_s_label_pos = [left_margin Vs_s_pos(2)+label_offset label_width label_height];

Vr_s_label_pos = [left_margin Vs_s_pos(2)-label_offset label_width label_height];

Vp_ss_pos =  [left_margin Vs_y slider_width slider_height];
Vp_ss_label_pos = [left_margin Vp_ss_pos(2)+label_offset label_width label_height];

Vr_ss_label_pos = [left_margin Vp_ss_pos(2)-label_offset label_width label_height];


%% -------------------
%%  Slider/Label Init
%% -------------------
high_ = 0.4; low_ = 0.4;

main_gui.Vp = ui_slider(main_gui.initial_panel, Vp_pos, high_);
main_gui.Vp_label = ui_text(main_gui.initial_panel, Vp_label_pos);

main_gui.Vs = ui_slider(main_gui.initial_panel, Vs_pos, low_);
main_gui.Vs_label = ui_text(main_gui.initial_panel, Vs_label_pos);

main_gui.Vr_label = ui_text(main_gui.initial_panel, Vr_label_pos, 'fontangle', 'italic');

main_gui.Vp_s = ui_slider(main_gui.response_panel, Vp_s_pos, high_);
main_gui.Vp_s_label = ui_text(main_gui.response_panel, Vp_s_label_pos);

main_gui.Vs_s = ui_slider(main_gui.response_panel, Vs_s_pos, low_);
main_gui.Vs_s_label = ui_text(main_gui.response_panel, Vs_s_label_pos);

main_gui.Vr_s_label = ui_text(main_gui.response_panel, Vr_s_label_pos, 'horizontalalignment', 'center', 'fontangle', 'italic');

main_gui.Vp_ss = ui_slider(main_gui.response_panel, Vp_ss_pos, high_);
main_gui.Vp_ss_label = ui_text(main_gui.response_panel, Vp_ss_label_pos);

main_gui.Vr_ss_label = ui_text(main_gui.response_panel, Vr_ss_label_pos, 'horizontalalignment', 'center', 'fontangle', 'italic');

main_gui.left_split = ui_text(main_gui.initial_panel, [0.3 mean([Vp_pos(2) Vs_pos(2)]) 1 0.05], ...
  'string', repmat('—', 1, 100), 'foregroundcolor', [0.6 0.6 0.6], 'horizontalalignment', 'right');
main_gui.right_split = ui_text(main_gui.response_panel, [0 mean([Vp_pos(2) Vs_pos(2)]) 1 0.05], ...
  'string', repmat('—', 1, 100), 'foregroundcolor', [0.6 0.6 0.6], 'horizontalalignment', 'center');


%% ---------------------
%%  Slider Callback Fcn
%% ---------------------
function update_sliders(fig, varargin)

  %%  data container holding the calling object (main_gui)
  gui = guidata(fig);

  %%  conditionally clamp a value strictly between (0,1); also round to nearest 1% for accurate labels
  clamp_nonzero = @(z,h) set(h, 'value', round(100*(z*get(h, 'value') + ~z*max(min(get(h, 'value'), 0.99), 0.01)))/100);
  allow_zero = get(gui.allow_zero, 'value');

  %%  clamp h1 such that h1+h2<=1
  clamp_one_minus = @(h1, h2) set(h1, 'value', min(get(h1, 'value'), 1 - get(h2, 'value')));

  if ~isempty(varargin)
    switch gcbo %%  gcbo is the handle of the calling object (slider)
      case gui.Vp
        clamp_nonzero(allow_zero, gui.Vp);
        clamp_one_minus(gui.Vs, gui.Vp);
      case gui.Vs
        clamp_nonzero(allow_zero, gui.Vs);
        clamp_one_minus(gui.Vp, gui.Vs);
      case gui.Vp_s
        clamp_nonzero(allow_zero, gui.Vp_s);
        clamp_one_minus(gui.Vs_s, gui.Vp_s);
      case gui.Vs_s
        clamp_nonzero(allow_zero, gui.Vs_s);
        clamp_one_minus(gui.Vp_s, gui.Vs_s);
      case gui.Vp_ss
        clamp_nonzero(allow_zero, gui.Vp_ss);
    end %switch
  end %if

  %%  Update text labels
  set_label = @(h_lab, str, h_val) set(h_lab, 'string', sprintf(strcat(str, ': %.0f%%'), get(h_val, 'value')*100));
  set_label_retreat = @(h_lab, varargin) set(h_lab, 'string', sprintf('Retreat: %.0f%%', max(0, (1 - sum([varargin{:}]))*100)));

  set_label(gui.Vp_label, 'Just Play', gui.Vp);
  set_label(gui.Vs_label, 'Snap First', gui.Vs);
  set_label(gui.Vp_s_label, 'Play on', gui.Vp_s);
  set_label(gui.Vs_s_label, 'Snap Back', gui.Vs_s);
  set_label(gui.Vp_ss_label, 'Play On', gui.Vp_ss);
  set_label_retreat(gui.Vr_label, get(gui.Vp, 'value'), get(gui.Vs, 'value'));
  set_label_retreat(gui.Vr_s_label, get(gui.Vp_s, 'value'), get(gui.Vs_s, 'value'));
  set_label_retreat(gui.Vr_ss_label, get(gui.Vp_ss, 'value'));

  %%  Compute best-response strategy and draw it
  waitfor(gui.axes, 'userdata', 'idle');
  set(gui.axes, 'userdata', 'running');
  display_strategy(gui, best_response(gui.w_tick, get(gui.Vp, 'value'), get(gui.Vs, 'value'), get(gui.Vp_s, 'value'), get(gui.Vs_s, 'value'), get(gui.Vp_ss, 'value')));

end %function


function strategy = best_response(w_tick, Vp, Vs, Vp_s, Vs_s, Vp_ss)

  Vr = 1 - Vp - Vs; Vr_s = 1 - Vp_s - Vs_s; Vr_ss = 1 - Vp_ss;
  %%  algorithm supports mixed strategies, but there exist no mixed solutions in this game
  strat_tick = 1; strat = 0:strat_tick:1;

  %%  initialize the entire potential strategy space
  [w, Hr, Hp, Hs, Hs_r, Hs_p, Hr_s, Hp_s, Hs_s] = ndgrid(0:w_tick:1, strat, strat, strat, strat, strat, strat, strat, strat);

  %%  indices of the elements that represent a legal strategy
  i = find((Hr + Hp + Hs == 1) & ...
           (Hs & (Hs_r + Hs_p == 1) | ~(Hs|Hs_r|Hs_p)) & ...
           (Hr_s + Hp_s + Hs_s == 1) & ...
           (Vp | ~Hr) & ...
           (Vs | ~Hr_s) & ...
           (Vs_s | ~Hs_r));

  %%  compute the ev of all valid strategies
  ev = NaN(size(w));
  ev(i) = Vr + Vp .* (-Hr(i) + Hp(i) .* (4*w(i)-2) + Hs(i) .* (Vr_s + Vp_s .* (8*w(i)-4) + Vs_s .* (-2*Hs_r(i) + Hs_p(i) .* (16*w(i)-8)))) ...
             + Vs .* (-Hr_s(i) + Hp_s(i) .* (8*w(i)-4) + Hs_s(i) .* (2*Vr_ss + Vp_ss .* (16*w(i)-8)));


  max_w_tick = 1/w_tick+1; s = zeros(max_w_tick, 8); s_idx = cell(8, 1);

  %%  find the value and indices of the max ev for each w-slice
  [best_ev, idx] = max(ev(1:max_w_tick,:), [], 2);
  sz_ = size(ev);
  [s_idx{:}] = ind2sub(sz_(2:end), idx);

  %%  each index represents the (Hr, Hp, Hs, ...) values after a simple conversion
  s(:) = (cell2mat(s_idx) - 1) * strat_tick;


  %%  we will also calculate the ev of playing the GTO strategy against this opponent
  gto_strategy = [repmat([1 0 0 0 0 1 0 0], 0.25/w_tick+1, 1); ...
                  repmat([0 1 0 0 0 1 0 0], (0.375-0.25)/w_tick, 1); ...
                  repmat([0 1 0 0 0 0 1 0], (0.5-0.375)/w_tick, 1); ...
                  repmat([0 0 1 0 1 0 0 1], 0.5/w_tick, 1)];
  w = (0:w_tick:1)';
  ev = @(s) Vr + Vp .* (-s(:,1) + s(:,2) .* (4*w-2) + s(:,3) .* (Vr_s + Vp_s .* (8*w-4) + Vs_s .* (-2*s(:,4) + s(:,5) .* (16*w-8)))) ...
                   + Vs .* (-s(:,6) + s(:,7) .* (8*w-4) + s(:,8) .* (2*Vr_ss + Vp_ss .* (16*w-8)));
  gto_ev = ev(gto_strategy);

  %%  Hr, Hp, Hs*Hs_r, Hs*Hs_p // Hr_s, Hp_s, Hs_s
  strategy = [s(:,1:2) s(:,3).*s(:,4:5) s(:,6:8) gto_ev best_ev];

end %function


function display_strategy(gui, strategy)

  cla(gui.axes);

  max_w_tick = size(strategy,1);
  ylims = get(gui.axes, 'ylim');

  strat = {1:4; 5:7};
  offset = [0 4];
  for ii = 1:length(strat)
    s_ = strat{ii}; offset_ = offset(ii);

    %%  locate the indices on the w-scale where the strategy changes
    [x_, ~] = find(diff(strategy(:,s_)));

    %%  pick one slice for each unique strategy
    s = strategy([1; unique(x_)+1],s_);

    %%  drawing N separate rectangles requires a 4 x N vector each for the x and y coords.
    x = [0 unique(x_)'-1 max_w_tick]*gui.w_tick;
    xs = [x(1:end-1); x(1:end-1); x(2:end); x(2:end)];
    ys = repmat([0 1 1 0]', 1, size(s,1)) * (ylims(2) - ylims(1))/2 + ~logical(offset_)*ylims(1) + logical(offset_)*mean(ylims);

    %%  index also determines color
    [col, ~] = find(s');
    patch(xs, ys, col+offset_);
  end %for

  if get(gui.show_ev, 'value')
      draw_ev(gui, strategy(1:max_w_tick, [8 9]));
  else
      legend off;
  end %if

  set(gui.axes, 'userdata', 'idle');

end %function


function draw_ev(gui, ev)

  gto = line(gui.axes, 0:gui.w_tick:1, ev(:,1), 'color', 'k', 'linewidth', 1, 'linestyle', '--');
  exploit = line(gui.axes, 0:gui.w_tick:1, ev(:,2), 'color', 'k', 'linewidth', 1);
  legend([gto exploit], {'GTO Strategy EV', 'Exploitative Strategy EV'}, 'location', 'northoutside', 'orientation', 'horizontal', 'fontsize', 12);
  legend boxoff;

end %function


%% -----------------
%%  Begin Execution
%% -----------------
guidata(main_fig, main_gui);
update_sliders(main_fig);

end %function
